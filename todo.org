* Sat todo file

* DONE Release initial version to hackage
  CLOSED: [2008-06-06 Fri 10:49]

* TODO [#A] Add unsatisfiable core extraction			       :feature:

Algorithm:

???

* TODO Add -funbox-strict-fields to the ghc-options                      :bench:
and see how it affects performance.

* TODO [#A] Remove stupid command-line options                         :cleanup:

* TODO [#C] Initial state for dynamic variable ordering should be
based on the number of occurrences of literals in the clause database at the
beginning, or something.  Some heuristic that puts important variables first
at the beginning, instead of starting out all at zero.

* DONE [#A] Remove the monad stack from bcpLit
  CLOSED: [2008-06-05 Thu 20:14]
There are three monads there!  Can we just write a single monad data type on
top of ST that has errors and whatnot?

Did this long ago.
** Result ...

* TODO On some problems, select is a bottleneck, much               :heuristics:
more than bcpLit.  Even so, reverting to a static ordering gives worse
runtime.  So ... if we had a faster way of selecting the min, it would be
nice.

* TODO Derive resolution proof of UNSAT in order to aid debugging      :feature:

* TODO There is a bug in mkConflGraph				       :ARCHIVE:
mkConflGraph' is the old code that seemed to work, but it's much slower.

* DONE Bug fixed
  CLOSED: [2008-05-08 Thu 22:17]
** decision list wasn't reset on restarts
** propQ wasn't reset on restarts

* TODO Problem simplification
** Whenever we restart, remove the negations of all unit facts from each clause.

* DONE [#A] Debug clause learning
  CLOSED: [2008-04-24 Thu 15:57]
Currently, bugs.

** There is a confusion between reasons and actual assigned variables
When asking for the level of a variable in the current assignment, the
conflict variable should be treated specially -- it's at the current level.
Otherwise, you can just ask for the level of the variable.

Say the conflicting literals is -20.  Then 20 is in the current assignment ---
that's why -20 conflicts.  Now, suppose you expand a literal `x' whose reason
contains -20 -- that is, since 20 is true, -20 was in a clause which became
unit, and propagated `x'.  Asking for the level of -20 is wrong -- when asking
for the level of a *reason*, we always want the level of the corresponding
variable, so that we don't confuse it with the conflicting literal.

* DONE VSIDS bumping should happen for each variable encountered
  CLOSED: [2008-06-05 Thu 20:15]
while generating the learnt clause.

* TODO [#K] Recursive learning/parallel stuff

* DONE Learned clause deletion
  CLOSED: [2008-04-03 Thu 12:18]

* DONE Make "bad" bag use bitset
  CLOSED: [2008-03-18 Tue 10:11]

* 29 Feb 2008 16:43:29
I had to re-install GHC 6.8.1 for a reason that is not important.  I was going
to install 6.8.2, which I had to compile myself.  While waiting for that, I
worked on DPLLSat with 6.8.1.  My tests run in 5 seconds, without
optimisations!  Last night I was waiting 10 minutes.  And this is user time!
I have no idea why.  I did change the unit propagation code today, but only
making it do more work!

I'm going to install 6.8.2, and then put 6.8.1 somewhere else so I can switch
between them easily, somehow.  Weird, weird.

This could be explained by a different test distribution ...

* DONE Make unit propagation propagate with learned clauses too.
  CLOSED: [2008-03-18 Tue 10:11]

* TODO [#K] Incorporate stupid frequency-based decision heuristic      :ARCHIVE:

* DONE Implement clause learning but only after
  CLOSED: [2008-03-18 Tue 10:11]
watched literals, otherwise the number of times we have to walk the set of
clauses will really kill the runtime.

* DONE Change watched literal imp so that we only propagate assignments
  CLOSED: [2008-02-22 Fri 11:37]
that have actually been made since the last iteration; this saves time.

So unitProp (maybe rename bcp?) should take a list of literals to propagate,
and compute until that list is emptied -- sounds like a worklist algorithm!

* TODO Implement SAT-MICRO annotated clauses and literals	       :ARCHIVE:
instead of using the current dl (decision list).

* TODO Probably don't need the cnf				       :ARCHIVE:
and wch fields of the state.  Probably can get away with some watcher.

* DONE [#A] Make watched literals work as follows:
  CLOSED: [2008-02-22 Fri 11:38]
-- watcherMap: Map Lit [((Lit, Lit), Clause)]

** When l first added to assignment (either decision or propagation):
if -l is watched, then for each clause associated with -l, look at -l's paired
literal, q.  If q is undefined under the assignment, then:

  -- If q is a unit literal of this clause, assign q.

  -- If q is *not* a unit literal of this clause, stop watching -l and
starting watching some other literal of the clause.  (Choose next by removing
everything in the assignment from the clause, then picking a random element.)

Write this in terms of a list of newly-assigned literals, so one can recurse
at the end.
  

* DONE [#A] Change assignment representation to O(1)
  CLOSED: [2008-02-13 Wed 21:59]
** DONE Lits to Int
   CLOSED: [2008-02-02 Sat 11:55]

